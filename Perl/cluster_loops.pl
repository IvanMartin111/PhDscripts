#!/usr/bin/perl

#Script for clustering the closed loops generated by RCD and select those best scored by KORP as representative for each cluster

#Iván Martín Hernández

# Date: JUN - 2022


use strict;
use warnings;
use diagnostics;
use Data::Dumper qw(Dumper);
use feature 'say';
use Switch;
use Scalar::Util qw(reftype);
use File::Basename;
use POSIX;

# INPUT PARSER
if( !($#ARGV == 1))
{
	say "USAGE:\n\t$0  <input1> \n";
	say "\t<input1>  --> File with the tsv (modify) of all the proteins of SabDab DB";
	say "\nDESCRIPTION:\n\tSay something here...";
	say "\nWARNING:\n\tSomething....";
	say "\nEXAMPLE:";	
	say "\tAB_SAbDab_sumarize.pl  sabdab_summary_all.tsv";
	say "\nHELP: some help\n";
	exit;
}

my %short = (
   "ALA" => "A",
	"CYS" => "C",
   "CYX" => "C",
   "ASP" => "D",
   "GLU" => "E",
   "PHE" => "F",
   "GLY" => "G",
   "HIS" => "H",
   "HSD" => "H",
   "HSE" => "H",
   "HSP" => "H",
   "HIP" => "H", # Rosseta
   "HID" => "H", # Rosseta
   "HIE" => "H", # Rosseta
   "ILE" => "I",
   "LYS" => "K",
   "LEU" => "L",
   "MET" => "M",
   "ASN" => "N",
   "PRO" => "P",
   "GLN" => "Q",
   "ARG" => "R",
   "SER" => "S",
   "THR" => "T",
   "VAL" => "V",
   "TRP" => "W",
   "TYR" => "Y",
   "  A" => "A",
   "  G" => "G",
   "  T" => "T",
   "  C" => "C",
   "  U" => "U",
   " DA" => "A",
   " DG" => "G",
   " DT" => "T",
   " DC" => "C" ) ;

#take the inputs from the bash
my $closedloops= $ARGV[0];
my $name=$ARGV[1];
my $rmsd_file= $name."_rmsd.txt";
#my $rmsd_file= "test_".$name."_rmsd.txt";
my $dh_file=$name."_dh.txt";
my $len_file=$name."_len.txt";
my $val_file=$name."_val.txt";

#Import the loop data form the closed pdbs file an keep it into a hash
open (DATA,$closedloops) or die "The file $closedloops doesn't exit in this path.\n";

print "$0 - Reading the loop file -- $closedloops\n";


my %Models;
my $modelid;

my $nline = 0; # Line index (counter)

while(<DATA>)
{
	next if /^#/; # reading only non-# beginning lines
	$_=~ s/^\t//;
	chop $_;
	#my @line = split(/\t/, $_);
	#push(@data,\@line);
	
	if ($_=~/^MODEL/){
		my @line = split(/\s+/, $_);
		$modelid=$line[1];
	}
	
	if ($_=~/^ATOM/){
		my $atom =readPDBLine($_);
		$Models{$modelid}{$$atom{seq}}=$atom;
	}
	$nline++;
}

close(DATA);

my %KORPENERGY;
open (KFIL,$rmsd_file) or die "The file $rmsd_file doesn't exit in this path.\n";
while(<KFIL>)
{
	next if /^#/; # reading only non-# beginning lines
	$_=~ s/^\t//;
	#chop $_;
	my @line = split(/\s+/, $_);
	my $loopid=$line[1]+1;
	my $loopKenergy=$line[6];
	
	$KORPENERGY{$loopid}=$loopKenergy;
}
close(KFIL);


my @KORPSsort; #Array that keeps the order of loops by Korp energy for later uses

print "$0 - Calculating RMSDs\n";
#
#open(OUT,'>',"Matrix_disimilarity.txt");
#printf OUT "    \t";
foreach my $model (sort {$KORPENERGY{$a} <=> $KORPENERGY{$b}} keys %Models){
#	printf OUT "%6s\t", $model;
	push (@KORPSsort,$model);
}
#printf OUT "\n";
#
##Make the table of disimilarity (using RMSD) between all loops    
#
#my $a1=0;
#foreach my $model1 (sort {$KORPENERGY{$a} <=> $KORPENERGY{$b}} keys %Models){
#	my @RMSDss;
#	$a1++;
#	my $a2=0;
#	foreach my $model2 (sort {$KORPENERGY{$a} <=> $KORPENERGY{$b}} keys %Models){
#		$a2++;
#		if ($a1<$a2) {
#			my $RMSD;
#			my @atoms =keys %{$Models{$model1}};
#			my $N =scalar(@atoms);
#			my $Sumatorie=0;
#			
#			foreach my $atom ( @atoms){
#				 #Taking only the CA atoms for the RMSD to save time in calc
#				if ($Models{$model1}{$atom}{name} eq " CA ") {
#					my $xdiff = $Models{$model1}{$atom}{x} -$Models{$model2}{$atom}{x};
#					my $xsq = $xdiff**2;
#				
#					my $ydiff = $Models{$model1}{$atom}{y} -$Models{$model2}{$atom}{y};
#					my $ysq = $xdiff**2;
#				
#					my $zdiff = $Models{$model1}{$atom}{z} -$Models{$model2}{$atom}{z};
#					my $zsq = $xdiff**2;
#				
#				
#					#print "$Models{$model1}{$atom}{name} - $Models{$model1}{$atom}{x} - $Models{$model2}{$atom}{x} = $xdiff --$xsq \n";
#					$Sumatorie=$Sumatorie+$xsq+$ysq+$zsq;
#                }
#			}
#			
#			my $SumN=$Sumatorie/$N;
#			$RMSD = sqrt($SumN);
#			
#			
#			#print "$model1 - $model2 - $Sumatorie -- $SumN ///$RMSD\n";
#			push (@RMSDss, $RMSD);
#
#		}
#		
#		if ($a1 eq $a2) {
#			push (@RMSDss, 0);
#		}
#		if ($a1 > $a2) {
#			push (@RMSDss, 0);
#		}	
#	}
#	printf OUT "%6s\t", $model1;
#	foreach my $RR (@RMSDss){printf OUT "%6.4f\t",$RR;}
#	printf OUT "\n";
#	#print $Models{$model}{'43'}{x}."\n";
#}
#
#close (OUT);
#



#### Send de r script to clusterify
print "$0 - Clustering with the r-script\n";
#system("Rscript ../../scripts/Cluster_table_min.r");



#### Read the clusters ID and the KORP energy
print "$0 - Selecting best decoys from each cluster\n";

my %clusters;
my @Clurster_IDs;
my %Selected_loops;
my $clus_file="C_IDs.txt";
my $value=6; 


open (CFIL,$clus_file) or die "The file $clus_file doesn't exit in this path.\n";
while(<CFIL>)
{
	chop $_;
	@Clurster_IDs = split(/\s+/, $_);
}
close(CFIL);


my $position=0;
foreach my $clus(@Clurster_IDs){
	
	print "$position -- $clus -- $KORPSsort[$position] - $KORPENERGY{$position+1}\n";
	
	$clusters{$clus}{$KORPSsort[$position]}=$KORPENERGY{$position+1};
	$position++;
}



foreach my $clus(sort {$a <=> $b} keys %clusters){
	print "$clus\n";
	my @order;
	
	foreach my $loop (sort {$clusters{$clus}{$a} <=> $clusters{$clus}{$b} } keys %{$clusters{$clus}}){
		print "$clus -- $loop -- $clusters{$clus}{$loop}\n";
		push (@order, ($loop+1));
	}
	
	if ($clus eq 0) {
		foreach my $loop(@order){
			$Selected_loops{$loop} =$clusters{$clus}{$loop-1};
		}
    }
    else{
		my $number=ceil(scalar(@order)/$value);
		#my $number=scalar(@order);
		#print "N=? $number \n";
		for(my $i = 0; $i < ($number); $i++ ){
			$Selected_loops{$order[$i]} =$clusters{$clus}{$order[$i]-1};
			#print "$i - $order[$i]-$Selected_loops{$order[$i]} -- $clusters{$clus}{$order[$i]-1}\n";
		}
	}
}




#Printing the top selected loops
print "$0 - Printing the top selected loops new files\n";

my $newclosedloops= "new_".$closedloops;
my $newrmsd_file= "new_".$rmsd_file;
my $newdh_file="new_".$dh_file;
my $newlen_file="new_".$len_file;
my $newval_file="new_".$val_file;
my $limit=scalar(keys %Models)/5;
#my $limit=scalar(keys %Models);


my $control=0;
my @finalSelectedLoops;
my @SortedfinalSelectedLoops;

foreach my $finloop(sort {$Selected_loops{$a} <=> $Selected_loops{$b} } keys %Selected_loops){
	#print "$finloop -- $Selected_loops{$finloop}\n";
	push(@finalSelectedLoops,$finloop);
	$control++;
	if ($control eq $limit) {last;}
}

@SortedfinalSelectedLoops = sort{ $a <=> $b } @finalSelectedLoops;
#foreach  my $lopp(@SortedfinalSelectedLoops){print "$lopp\n";}
	
##########
#Printing the Rosseta output with the selected loop comment this section if rosseta 10K have not been run before
my $newname="3umt_4_native_ori_50K_3umt_2022S_iv_95_070_3_rosetta_RClust.txt";
my $newnameS="3umt_4_native_ori_50K_3umt_2022S_iv_95_070_3_rosetta_RClustS.txt";
my $loopsresults="3umt_4_native_ori_50K_3umt_2022S_iv_95_070_3_rosetta.txt";	
	
	
print "\nPrinting: $newname\n";

open(OUT,'>',$newname);

open (DATA,$loopsresults) or die "The file $loopsresults doesn't exit in this path.\n";

my $contn=0;
while(<DATA>)
{
	if (/^#/) {
		printf OUT $_;
	}
	$_=~ s/^\t//;
	$_=~ s/^\s+//;
	#$_=~ s/\s//;
	chop $_;
	
	my @line = split(/\s+/, $_);
	
	foreach my $selected (@SortedfinalSelectedLoops){
		if ($selected eq $line[0]) {
	    	printf OUT "    $_\n";
		}
	}
    
	
}
close(DATA);
close(OUT);


system ("cat $newname |sort -k 9 -n > $newnameS");
	
	
	
	
	# ClosedLoop file
open (PDB,">$newclosedloops") or die "Failed to open $newclosedloops\n";
$control=1;
foreach my $finloop(sort {$a <=> $b}  @SortedfinalSelectedLoops){
	open(PDB,">>$newclosedloops") or die "Failed to open $newclosedloops\n";
	printf PDB "%5s %8d\n","MODEL", $control;

	
	close (PDB);
	
	foreach my $atom (sort {$a <=> $b} keys  %{$Models{$finloop}} ){
		#print "$Models{$finloop}{$atom}{x}\n";
		writelinePDB($Models{$finloop}{$atom},$newclosedloops);	
	}
	open(PDB,">>$newclosedloops") or die "Failed to open $newclosedloops\n";
	printf PDB "ENDMDL\n";
	close (PDB);
	$control++;
}
	
	
	# RMSD file
$control=0;
open (RMSD,$rmsd_file) or die "The file $rmsd_file doesn't exit in this path.\n";
open (RMSDOUT,">$newrmsd_file") or die "Failed to open $newrmsd_file\n";
$nline = 1;
while(<RMSD>)
{
	if (/^#/) {
		open (RMSDOUT,">>$newrmsd_file") or die "Failed to open $newrmsd_file\n";
		printf RMSDOUT "$_";
		close (RMSDOUT);
	}
	else{
		if ($nline eq $SortedfinalSelectedLoops[$control]) {
            #print "$control - $SortedfinalSelectedLoops[$control] -- $nline \n$_\n";
			my @line = split(/\s+/, $_);
			$line[1]=$control;
			open (RMSDOUT,">>$newrmsd_file") or die "Failed to open $newrmsd_file\n";
			#printf RMSDOUT "$_";
			printf RMSDOUT"%8d %8.3f %8.3f %8.3f %8.3f %10.5f\n", $line[1],$line[2],$line[3],$line[4],$line[5],$line[6];
			## native      0.0    0.000        -        -   -481.381
			#       0    3.234    0.000    0.000    0.000 -243.93928
			
			close (RMSDOUT);
			$control++;
        }
		$nline++;
	}
	if ($control eq $limit) {last;}
}
close (RMSD);
	
	
	
	
	# DH file
$control=0;
open (DH,$dh_file) or die "The file $dh_file doesn't exit in this path.\n";
$nline = 1;
while(<DH>)
{
	if (/^#/) {
		open (DHOUT,">$newdh_file") or die "Failed to open $newdh_file\n";
		printf DHOUT "$_";
		close (DHOUT);
	}
	else{
		if ($nline eq $SortedfinalSelectedLoops[$control]) {
            #print "$control - $SortedfinalSelectedLoops[$control] -- $nline \n$_\n";
			open (DHOUT,">>$newdh_file") or die "Failed to open $newdh_file\n";
			printf DHOUT "$_";
			close (DHOUT);
			$control++;
        }
		$nline++;
	}
	if ($control eq $limit) {last;}
}
close (DH);

# LEN file
$control=0;
open (LEN,$len_file) or die "The file $len_file doesn't exit in this path.\n";
$nline = 1;
while(<LEN>)
{
	if (/^#/) {
		open (LENOUT,">$newlen_file") or die "Failed to open $newlen_file\n";
		printf LENOUT "$_";
		close (LENOUT);
	}
	else{
		if ($nline eq $SortedfinalSelectedLoops[$control]) {
            #print "$control - $SortedfinalSelectedLoops[$control] -- $nline \n$_\n";
			open (LENOUT,">>$newlen_file") or die "Failed to open $newlen_file\n";
			printf LENOUT "$_";
			close (LENOUT);
			$control++;
        }
		$nline++;
	}
	if ($control eq $limit) {last;}
}
close (LEN);

# VAL file
$control=0;
open (VAL,$val_file) or die "The file $val_file doesn't exit in this path.\n";
$nline = 1;
while(<VAL>)
{
	if (/^#/) {
		open (VALOUT,">$newval_file") or die "Failed to open $newval_file\n";
		printf VALOUT "$_";
		close (VALOUT);
	}
	else{
		if ($nline eq $SortedfinalSelectedLoops[$control]) {
            #print "$control - $SortedfinalSelectedLoops[$control] -- $nline \n$_\n";
			open (VALOUT,">>$newval_file") or die "Failed to open $newval_file\n";
			printf VALOUT "$_";
			close (VALOUT);
			$control++;
        }
		$nline++;
	}
	if ($control eq $limit) {last;}
}
close (VAL);


#change names for the input eworking of refine loops


system ("mv $closedloops old_$closedloops");
system ("mv $newclosedloops $closedloops");

system ("mv $rmsd_file old_$rmsd_file");
system ("mv $newrmsd_file $rmsd_file");

system ("mv $dh_file old_$dh_file");
system ("mv $newdh_file $dh_file");

system ("mv $len_file old_$len_file");
system ("mv $newlen_file $len_file");

system ("mv $val_file old_$val_file");
system ("mv $newval_file $val_file");


print "Commands to reverse rename files\n";
print "mv  $closedloops $newclosedloops\n";
print "mv  old_$closedloops $closedloops\n";

print "mv  $rmsd_file $newrmsd_file\n";
print "mv  old_$rmsd_file $rmsd_file\n";


print "mv  $dh_file $newdh_file\n";
print "mv  old_$dh_file $dh_file\n";


print "mv  $len_file $newlen_file\n";
print "mv  old_$len_file $len_file\n";


print "mv  $val_file $newval_file\n";
print "mv  old_$val_file $val_file\n";






###########################
#     FUNCTION
###########################

sub readPDBLine 
{
        my $line = shift;
        my $newAt = {};
        $newAt->{tag}=substr($line, 0,6);
        $newAt->{seq}=int(substr($line, 6,5));
        $newAt->{name}=substr($line, 12,4);
        $newAt->{altloc}=substr($line, 16,1);
        $newAt->{residueId}=substr($line,17,3);
        $newAt->{chain}=substr($line,21,1);
        $newAt->{resseq}=int(substr($line,22,4));
		  $newAt->{achar}=substr($line,26,1);
        $newAt->{x}=substr($line,30,8);
        $newAt->{y}=substr($line,38,8);
        $newAt->{z}=substr($line,46,8);
        $newAt->{occ}=substr($line, 54,6);
        $newAt->{Bfact}=substr($line, 60,6);
        $newAt->{charge}=$newAt->{occ};
        $newAt->{type}=substr($newAt->{name},1,1);
        return $newAt;
# Atomic Coordinate Entry Format Version 3.2
# http://www.wwpdb.org/documentation/format32/sect9.html
# COLUMNS        DATA  TYPE    FIELD        DEFINITION
#-------------------------------------------------------------------------------------
# 1 -  6        Record name   "ATOM  "
# 7 - 11        Integer       serial       Atom  serial number.
#13 - 16        Atom          name         Atom name.
#17             Character     altLoc       Alternate location indicator.
#18 - 20        Residue name  resName      Residue name.
#22             Character     chainID      Chain identifier.
#23 - 26        Integer       resSeq       Residue sequence number.
#27             AChar         iCode        Code for insertion of residues.
#31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
#39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
#47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
#55 - 60        Real(6.2)     occupancy    Occupancy.
#61 - 66        Real(6.2)     tempFactor   Temperature  factor.
#77 - 78        LString(2)    element      Element symbol, right-justified.
#79 - 80        LString(2)    charge       Charge  on the atom.
}

# Writes a pdb-file form a "array of hashes" format
sub writePDB 
{
  # "%6c%5c%*c%4c%c%3c%*c%c%4d%c%*3c%8c%8c%8c%6c%6c%c%3c"
  my $data=shift;
  my $file=shift;
  my $renum=shift;
  open(PDB,">$file") or die "\nFailed to open $file\n";
  if($renum eq undef) # no renumber atom index
  {
	  foreach(@{$data})
	  {
	    printf PDB "%6s%5s %4s%s%3s %s%4s%s   %8s%8s%8s%6s%6s\n",
	      $_->{tag},
	      $_->{seq},
	      $_->{name},
	      $_->{altloc},
	      $_->{residueId},
	      $_->{chain},
	      $_->{resseq},
	      " ",
	      $_->{x},
	      $_->{y},
	      $_->{z},
	      $_->{occ},
	      $_->{Bfact};
	  }
  }
  else # renumber atom index
  {
	  my $index=1;
	  foreach(@{$data})
	  {
	    printf PDB "%6s%5s %4s%s%3s %s%4s%s   %8s%8s%8s%6s%6s\n",
	      $_->{tag},
	      $index,
	      $_->{name},
	      $_->{altloc},
	      $_->{residueId},
	      $_->{chain},
	      $_->{resseq},
	      " ",
	      $_->{x},
	      $_->{y},
	      $_->{z},
	      $_->{occ},
	      $_->{Bfact};
	    $index++;
	  }
  }
  close(PDB);
}

sub writelinePDB 
{
  # "%6c%5c%*c%4c%c%3c%*c%c%4d%c%*3c%8c%8c%8c%6c%6c%c%3c"
	my $data=shift;
	my $file=shift;
	open(PDB,">>$file") or die "\nFailed to open $file\n";

	printf PDB "%6s%5s %4s%s%3s %s%4s%s   %8s%8s%8s%6s%6s\n",
	$data->{tag},
	$data->{seq},
	$data->{name},
	$data->{altloc},
	$data->{residueId},
	$data->{chain},
	$data->{resseq},
	" ",
	$data->{x},
	$data->{y},
	$data->{z},
	$data->{occ},
	$data->{Bfact};

	close(PDB);
}






# Reads a pdb-file from a file
sub readPDB
{
  my $file=shift; # PDB file
  my @data=(); # The readed PDB will be stored here.
  
  my $debug=0;
  my $cont=0;
  open(PDB,"$file") or die "\nFailed to open $file\n";
  while(<PDB>)
  {
    next unless /^ATOM/; # reading only ATOM begining lines
    push(@data,readPDBLine($_));
#    printf "%5d bfact= %10.2f\n",$cont+1,$data[$cont]->{Bfact} if $debug;
    $cont++;
  }
  close PDB;
  return(\@data);
}


